Searching 130 files for "readline"

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/history.h:
   57  void				execute_search_command(void);
   58  void				give_up_search(void);
   59: void 				back_to_readline(void);
   60  int 				find_in_history(int save);
   61  void				file_from_history(t_history *hist);

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/history/search_in_history.c:
   17  	{RET, 1, execute_search_command},
   18  	{ESC, 1, give_up_search},
   19: 	{TAB, 1, back_to_readline}
   20  };
   21  

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/history/search_in_history_actions.c:
   50  	if (!buff[0])
   51  		return ;
   52: 	back_to_readline();
   53  	if (g_shell.hist.unicode_err == 1)
   54  	{
   ..
   61  }
   62  
   63: void	back_to_readline(void)
   64  {
   65  	t_history	*curr;

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/lexer/lexer.c:
  144  	{
  145  		if (lex->quoted)
  146: 			readline(QUOTE_PROMPT);
  147  		else
  148: 			readline(BACKSLASH_PROMPT);
  149  		if (!g_shell.line || g_shell.edit.ret_ctrl_c)
  150  			return (1);

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/line_editing.h:
  230  void					modify_term(void);
  231  void					reset_term(void);
  232: void					readline(int prompt_id);
  233: void					readline_errors_controler(int errnum);
  234  void					build_key(uint8_t *key, size_t *keylen, const uint8_t *input);
  235  void					add_char_to_list(uint8_t *charac, size_t len, int is_prompt);

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/readline.h:
    2  /*                                                                            */
    3  /*                                                        :::      ::::::::   */
    4: /*   readline.h                                         :+:      :+:    :+:   */
    5  /*                                                    +:+ +:+         +:+     */
    6  /*   By: schakor <marvin@42.fr>                     +#+  +:+       +#+        */
    .
   11  /* ************************************************************************** */
   12  
   13: #ifndef READLINE_H
   14: # define READLINE_H
   15  
   16  # include "rl_defines.h"
   ..
   18  
   19  /*
   20: **		readline utility that allows the user to edit the command line
   21  */
   22  
   ..
   43  };
   44  
   45: void					readline(void);
   46  void					rl_get_prompt(t_rl *rl);
   47  void					rl_display_prompt(const char *prompt);

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/readline/character_controler.c:
   61  	prev_char = g_shell.edit.point_char;
   62  	if (!(new_char = malloc(sizeof(*new_char))))
   63: 		readline_errors_controler(MALLOC_ERROR);
   64  	ft_memset(new_char, 0, sizeof(*new_char));
   65  	ft_memmove(new_char->charac, charac, len);

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/readline/copy_controler.c:
   38  	cpy_size = get_cpy_size(curr, cpy_end);
   39  	if (!(buff = (uint8_t*)malloc(sizeof(uint8_t) * (cpy_size + 1))))
   40: 		readline_errors_controler(MALLOC_ERROR);
   41  	buff[cpy_size] = '\0';
   42  	i = 0;

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/readline/readline.c:
    2  /*                                                                            */
    3  /*                                                        :::      ::::::::   */
    4: /*   readline.c                                         :+:      :+:    :+:   */
    5  /*                                                    +:+ +:+         +:+     */
    6  /*   By: aguillot <marvin@42.fr>                    +#+  +:+       +#+        */
    .
   93  }
   94  
   95: void		readline(int prompt_id)
   96  {
   97  	uint8_t *prompt;

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/readline/readline_errors_controler.c:
    2  /*                                                                            */
    3  /*                                                        :::      ::::::::   */
    4: /*   readline_errors_controler.c                        :+:      :+:    :+:   */
    5  /*                                                    +:+ +:+         +:+     */
    6  /*   By: aguillot <marvin@42.fr>                    +#+  +:+       +#+        */
    .
   19  }
   20  
   21: void		readline_errors_controler(int errnum)
   22  {
   23  	cooked_terminal();

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/readline/return_fn.c:
   45  		buff_size = get_buf_size(head, g_shell.edit.char_list.tail);
   46  	if (!(buff = (uint8_t*)malloc(sizeof(uint8_t) * (buff_size + 2))))
   47: 		readline_errors_controler(MALLOC_ERROR);
   48  	buff[buff_size] = '\n';
   49  	buff[buff_size + 1] = '\0';

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/shell.h:
   14  # define SHELL_H
   15  
   16: enum e_readline_type
   17  {
   18: 	TERMCAPS_READLINE,
   19  	SIMPLE_REALINE
   20  };

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/signal/signal_handler.c:
   22  	//window_modif_test();
   23  	if ((ioctl(STDERR_FILENO, TIOCGWINSZ, &g_shell.edit.term_info.max)) == -1)
   24: 		readline_errors_controler(NO_TERM_INFO);
   25  	if ((g_shell.edit.term_info.max.ws_row < 15  && g_shell.edit.term_info.max.ws_col < 40)
   26  		|| g_shell.edit.term_info.max.ws_row < 10 || g_shell.edit.term_info.max.ws_col < 30)

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/terminal/run_shell.c:
   33  				g_shell.line = NULL;
   34  			}
   35: 			readline(prompt);
   36  			if (!g_shell.line || g_shell.edit.ret_ctrl_c)
   37  			{

/Users/aguillot/code/projects/UNIX/42_21sh/anteo/src/terminal/shell.c:
   66  	g_shell.raw_tio.c_cc[VTIME] = 0;
   67  	g_shell.debug_mode = 0;
   68: 	return (TERMCAPS_READLINE);
   69  }

25 matches across 15 files
