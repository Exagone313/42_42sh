
Voir le terminal comme un echiquier.
On fonctionne avec des t_char qui ont des positions x et y. On ne veut print que le strict minimum (que les t_chars dont les positions sont affichables).
Quand tu rajoutes des chars, ca fait bouger les positions des précédents.

MANDATORY
1.print_prompt(uint8_t *prompt);
2.clean_screen_from(size_t x, size_t y); --> Le clean_screen() precedant faisait scroll le contenu vers le haut quand il le fallait, celui la ne le fait plus.
3.calculate_pos();		--> Il faut que cette fonction ET toutes celles qui en découlent soient parfaitement comprises et fonctionnelles.
														Cas vicieux:	a. La position du t_char précédent correspond a la derniere position de l'echiquier.
																			Il faut alors "créer" une nouvelle ligne en soustrayant 1 a tous les y des t_char precedants y compris le base_curr_y (auquel cas il faut garder sa valeur precedente en memoire avec pour se faire un int PREV_Y_POS dans la globale), 
																			puis output un \n (dans le clean_and_print surement, si \n est output pour cette raison, il faut changer PREV_Y_POS pour qu'il soit egal a ACTUAL_Y_POS)
																				a.1. Il faut update le PREV_Y_POS a chaque fois qu'on update le Y_POS, donc dans calculate pos et search history.
																		b. Un t_char est ajouté en milieu de liste, il faut recalculer la position de tous les t_chars de la liste en faisant attention au (a) pour le dernier t_char.
																			LES CAS A ET B DE CETTE SECTION NE CONCERNENT QUE L'AJOUT DE T_CHAR.
																		c. Sur les cas particuliers des fonctions comme del_charac() qui demandent un calcul de pos, si le t_char que l'on delete n'est pas affiché a l'ecran, comportement indeterminé.

4.clean_and_print();	--> Cette fonction fait 5 choses distinctes: 	a. elle vérifie que la taille verticale de ce qui va etre print n'a pas augmenté en regardant si curr_base_y n'a pas changé, et si ca a changé elle output un \n. (Fait scroll le content up?)
																		b. elle clean l'ecran de ce qui a precedemment ete imprimé a l'aide de clean_screen_from().
																	  	c. elle vérifie ce qui est affichable dans le prompt et le reste de la ligne, grace a la position du curseur, et surtout grace a la position des t_chars eux memes. !!! METTRE L'ACCENT SUR CE POINT !!!
																	  		{Est ce fait en amont lors du calcul de la position des t_char?}
																	  	e. elle transforme les t_char adéquats en buffer.
																	  	f. elle print le buffer. (Les t_char prints ne sont que ceux qui sont affichables, du coup normalement pas besoin de check_all_pos a la fin de print)
																	  	g. elle replace le curseur à l'endroit voulu.
						Elle vérifie aussi l'intégrité de ce qui est affiché a l'ecran: a. Lorsque le dernier caractere est dans la derniere case de l'échiquier (position x & y max),
																							elle va afficher un bon vieux \n par soucis de propreté. (lire (a) de calculate_pos() + (a) de cette section).
5.cpy_fn();				--> Faut que ce soit nickel:					a. Lorsque on ajoute le buff a char_list, il faut annoncer a print plus de \n, parce que la il en fait un seul le fdp.
																		b. copy word a refacto.
6.transpose_word();		--> Faut que ce soit nickel:					a. On peut reconstruire un buff avec les deux mots a swap, puis on part du buff pour modifier la liste chainée.!!!--------(0)>
																		b. On garde les listes chainees. Dans ce cas la, on pourrait trouver un point de symmetrie pour inverser les deux mots.
																			b.1. Mieux: on garde la lettre de celui qu'on va remplacer dans un tmp, ensuite on remplace par le precedant, puis on remplace le precedant par tmp.



																			saefff         esef   fdf
7.delete_word();																												
8.del_fns();															a. PB avec delete_backline(). Si on essaie de delete alors que le prompt n'est pas visible ca pete.
																			a.1. Le del_charac_from_list ne fait change pas les y_pos, donc quand print veut reafficher, il trouve pas par ou commencer. ()
9. Movement_fn(); 														a. Move left a la limite de l'ecran
																		b. Move backward/forward word
																		c. Move up/down
																		d. Home/end
10.undo_last_command();
11.free_all_edit();														a. Definition des define: FREE_ALL_EDIT: free les nodes de la list et free le buf copy
12.ctrl_r();															if you wright shit it should return nommat
12.Norme.

13.Undo_last_editing_command();											a. il faut que lorsqu'on check key, on fasse passer le resultat si sa match par un certain endroit, ensuite on peut comparrer les deux chained list (avant/apres) pour savoir que faire des modifs.
																		b. A l'instantiation du shell, si l'afichage du prompt reussit, il faut creer la liste chainee du undo juste avec le prompt.
																		c. A chaque fois qu'une commande qui modifie ce qui est affiché ou que quelque chose est ecrit, on ajoute un node dans la liste avec le buff actuel (avant que la commande soit exec) et la
																			position du curseur par rapport a la liste chainee.
																		


14. SEGFAULT (04/04/2019): Lorsque on ecrit plus que la taille du terminal et qu'on delete avec ctrl + w quand on peut et del autrement, au dernier delete avant de voir le prompt reaparaitre ca pete
15. SEGFAULT (09/04/2019): Lorsque on cherche dans l'historique avec ctrl + R et qu'on ecrit la derniere lettre d'un mot pus une apres ca pete.

OPTIONAL
raw_terminal, cooked_terminal.
Input_controller, put readig state in options.

	{CTRL_A, 1, go_to_home},
		{CTRL_B, 1, move_left},
		{CTRL_C, 1, handle_ctrl_c},
		{CTRL_D, 1, eot_fn},
		{CTRL_E, 1, go_to_end},
		{CTRL_F, 1, move_right},
		{CTRL_K, 1, delete_endline},
		{CTRL_N, 1, get_next_history},
		{CTRL_P, 1, get_prev_history},
		{CTRL_R, 1, search_in_history},
		{CTRL_T, 1, drag_char},
		{ALT_T, 2, transpose_word},
		{CTRL_U, 1, delete_backline},
		{CTRL_W, 1, delete_word_backward},
		{CTRL_P, 1, get_prev_history},
		{CTRL_N, 1, get_next_history},
		{CTRL_Y, 1, paste_copy},
		{CTRL_X_CTRL_X, 2, exchange_point_mark},
		{ESC_B, 2, jump_word_backward},
		{ESC_D, 2, delete_word_forward},
		{ESC_F, 2, jump_word_forward},
		{RIGHT_ARROW, 3, move_right},
		{LEFT_ARROW, 3, move_left},
		{UP_ARROW, 3, get_prev_history},
		{DOWN_ARROW, 3, get_next_history},
		{UP_LINE, 2, move_up},
		{DOWN_LINE, 2, move_down},
		{HOME, 3, go_to_home},
		{END, 3, go_to_end},
		{FORWARD_WORD, 2, jump_word_forward},
		{BACKWARD_WORD, 2, jump_word_backward},
		{DEL, 1, del_charac},
		{SUPR, 4, supr_charac},
		{CPY_CURR_WORD, 2, copy_current_word},
		{CPY_ALL_LINE, 2, copy_all_line},
		{PASTE, 2, paste_copy},
		{RET, 1, return_fn}